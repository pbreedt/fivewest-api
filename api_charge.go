/*
FiveWest Client API

API Documentation for FiveWest's wallet and RfQ trading services. Please visit dashboard.fivewest.co.za to sign up. Once your account has been verified to the sufficient level necessary for the given service, you can create an API key and secret with fine-grained service permissions in the 'API Management' section of the 'Profile' tab. These credentials must be provided in the /profile/api/v1/auth/token route in order to acquire a JWT to make further requests with. This JWT is valid for one week; the credentials do not expire but may be deleted.

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package fivewestapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)


// ChargeAPIService ChargeAPI service
type ChargeAPIService service

type ApiCreateApiV1ChargePostRequest struct {
	ctx context.Context
	ApiService *ChargeAPIService
	chargeData *ChargeData
}

func (r ApiCreateApiV1ChargePostRequest) ChargeData(chargeData ChargeData) ApiCreateApiV1ChargePostRequest {
	r.chargeData = &chargeData
	return r
}

func (r ApiCreateApiV1ChargePostRequest) Execute() (*ChargeResponse, *http.Response, error) {
	return r.ApiService.CreateApiV1ChargePostExecute(r)
}

/*
CreateApiV1ChargePost Create

Create a new charge.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateApiV1ChargePostRequest
*/
func (a *ChargeAPIService) CreateApiV1ChargePost(ctx context.Context) ApiCreateApiV1ChargePostRequest {
	return ApiCreateApiV1ChargePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChargeResponse
func (a *ChargeAPIService) CreateApiV1ChargePostExecute(r ApiCreateApiV1ChargePostRequest) (*ChargeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChargeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChargeAPIService.CreateApiV1ChargePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payments/api/v1/charge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chargeData == nil {
		return localVarReturnValue, nil, reportError("chargeData is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.chargeData
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeactivateApiV1ChargeIdPatchRequest struct {
	ctx context.Context
	ApiService *ChargeAPIService
	id Id1
}

func (r ApiDeactivateApiV1ChargeIdPatchRequest) Execute() (*http.Response, error) {
	return r.ApiService.DeactivateApiV1ChargeIdPatchExecute(r)
}

/*
DeactivateApiV1ChargeIdPatch Deactivate

Delete an active charge by supplying a charge ID or order ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiDeactivateApiV1ChargeIdPatchRequest
*/
func (a *ChargeAPIService) DeactivateApiV1ChargeIdPatch(ctx context.Context, id Id1) ApiDeactivateApiV1ChargeIdPatchRequest {
	return ApiDeactivateApiV1ChargeIdPatchRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
func (a *ChargeAPIService) DeactivateApiV1ChargeIdPatchExecute(r ApiDeactivateApiV1ChargeIdPatchRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChargeAPIService.DeactivateApiV1ChargeIdPatch")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payments/api/v1/charge/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HTTPResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiGetAllApiV1ChargeGetRequest struct {
	ctx context.Context
	ApiService *ChargeAPIService
	orderCurrencyId *string
	status *ChargeStatus
	page *int32
	pageSize *int32
	transactionCurrencyId *string
	transactionStatus *TransactionStatus
	transactionHash *string
	start *time.Time
	end *time.Time
}

func (r ApiGetAllApiV1ChargeGetRequest) OrderCurrencyId(orderCurrencyId string) ApiGetAllApiV1ChargeGetRequest {
	r.orderCurrencyId = &orderCurrencyId
	return r
}

func (r ApiGetAllApiV1ChargeGetRequest) Status(status ChargeStatus) ApiGetAllApiV1ChargeGetRequest {
	r.status = &status
	return r
}

func (r ApiGetAllApiV1ChargeGetRequest) Page(page int32) ApiGetAllApiV1ChargeGetRequest {
	r.page = &page
	return r
}

func (r ApiGetAllApiV1ChargeGetRequest) PageSize(pageSize int32) ApiGetAllApiV1ChargeGetRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetAllApiV1ChargeGetRequest) TransactionCurrencyId(transactionCurrencyId string) ApiGetAllApiV1ChargeGetRequest {
	r.transactionCurrencyId = &transactionCurrencyId
	return r
}

func (r ApiGetAllApiV1ChargeGetRequest) TransactionStatus(transactionStatus TransactionStatus) ApiGetAllApiV1ChargeGetRequest {
	r.transactionStatus = &transactionStatus
	return r
}

func (r ApiGetAllApiV1ChargeGetRequest) TransactionHash(transactionHash string) ApiGetAllApiV1ChargeGetRequest {
	r.transactionHash = &transactionHash
	return r
}

func (r ApiGetAllApiV1ChargeGetRequest) Start(start time.Time) ApiGetAllApiV1ChargeGetRequest {
	r.start = &start
	return r
}

func (r ApiGetAllApiV1ChargeGetRequest) End(end time.Time) ApiGetAllApiV1ChargeGetRequest {
	r.end = &end
	return r
}

func (r ApiGetAllApiV1ChargeGetRequest) Execute() (*PageChargeResponse, *http.Response, error) {
	return r.ApiService.GetAllApiV1ChargeGetExecute(r)
}

/*
GetAllApiV1ChargeGet Get All

Get all active or complete charges.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllApiV1ChargeGetRequest
*/
func (a *ChargeAPIService) GetAllApiV1ChargeGet(ctx context.Context) ApiGetAllApiV1ChargeGetRequest {
	return ApiGetAllApiV1ChargeGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PageChargeResponse
func (a *ChargeAPIService) GetAllApiV1ChargeGetExecute(r ApiGetAllApiV1ChargeGetRequest) (*PageChargeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PageChargeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChargeAPIService.GetAllApiV1ChargeGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payments/api/v1/charge"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.orderCurrencyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_currency_id", r.orderCurrencyId, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 0
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
	} else {
		var defaultValue int32 = 1
		r.pageSize = &defaultValue
	}
	if r.transactionCurrencyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transaction_currency_id", r.transactionCurrencyId, "")
	}
	if r.transactionStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transaction_status", r.transactionStatus, "")
	}
	if r.transactionHash != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transaction_hash", r.transactionHash, "")
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOneApiV1ChargeIdGetRequest struct {
	ctx context.Context
	ApiService *ChargeAPIService
	id Id
}

func (r ApiGetOneApiV1ChargeIdGetRequest) Execute() (*ChargeResponse, *http.Response, error) {
	return r.ApiService.GetOneApiV1ChargeIdGetExecute(r)
}

/*
GetOneApiV1ChargeIdGet Get One

Get one charge associated with a specific charge ID or order ID.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @return ApiGetOneApiV1ChargeIdGetRequest
*/
func (a *ChargeAPIService) GetOneApiV1ChargeIdGet(ctx context.Context, id Id) ApiGetOneApiV1ChargeIdGetRequest {
	return ApiGetOneApiV1ChargeIdGetRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
	}
}

// Execute executes the request
//  @return ChargeResponse
func (a *ChargeAPIService) GetOneApiV1ChargeIdGetExecute(r ApiGetOneApiV1ChargeIdGetRequest) (*ChargeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChargeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChargeAPIService.GetOneApiV1ChargeIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payments/api/v1/charge/{id}"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HTTPResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
