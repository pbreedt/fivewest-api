/*
FiveWest Client API

API Documentation for FiveWest's wallet and RfQ trading services. Please visit dashboard.fivewest.co.za to sign up. Once your account has been verified to the sufficient level necessary for the given service, you can create an API key and secret with fine-grained service permissions in the 'API Management' section of the 'Profile' tab. These credentials must be provided in the /profile/api/v1/auth/token route in order to acquire a JWT to make further requests with. This JWT is valid for one week; the credentials do not expire but may be deleted.

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package fivewestapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)


// TransactionAPIService TransactionAPI service
type TransactionAPIService service

type ApiCreateApiV1TransactionPostRequest struct {
	ctx context.Context
	ApiService *TransactionAPIService
	chargeId *string
	symbol *string
	network *string
	currencyId *string
}

func (r ApiCreateApiV1TransactionPostRequest) ChargeId(chargeId string) ApiCreateApiV1TransactionPostRequest {
	r.chargeId = &chargeId
	return r
}

func (r ApiCreateApiV1TransactionPostRequest) Symbol(symbol string) ApiCreateApiV1TransactionPostRequest {
	r.symbol = &symbol
	return r
}

func (r ApiCreateApiV1TransactionPostRequest) Network(network string) ApiCreateApiV1TransactionPostRequest {
	r.network = &network
	return r
}

func (r ApiCreateApiV1TransactionPostRequest) CurrencyId(currencyId string) ApiCreateApiV1TransactionPostRequest {
	r.currencyId = &currencyId
	return r
}

func (r ApiCreateApiV1TransactionPostRequest) Execute() (*TransactionResponse, *http.Response, error) {
	return r.ApiService.CreateApiV1TransactionPostExecute(r)
}

/*
CreateApiV1TransactionPost Create

Create a transaction for a given charge.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateApiV1TransactionPostRequest
*/
func (a *TransactionAPIService) CreateApiV1TransactionPost(ctx context.Context) ApiCreateApiV1TransactionPostRequest {
	return ApiCreateApiV1TransactionPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TransactionResponse
func (a *TransactionAPIService) CreateApiV1TransactionPostExecute(r ApiCreateApiV1TransactionPostRequest) (*TransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionAPIService.CreateApiV1TransactionPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payments/api/v1/transaction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.chargeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "charge_id", r.chargeId, "")
	}
	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "")
	}
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network", r.network, "")
	}
	if r.currencyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency_id", r.currencyId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HTTPResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllApiV1TransactionGetRequest struct {
	ctx context.Context
	ApiService *TransactionAPIService
	chargeId *string
	currencyId *string
	symbol *string
	network *string
	status *TransactionStatus
	late *bool
	page *int32
	pageSize *int32
	start *time.Time
	end *time.Time
}

func (r ApiGetAllApiV1TransactionGetRequest) ChargeId(chargeId string) ApiGetAllApiV1TransactionGetRequest {
	r.chargeId = &chargeId
	return r
}

func (r ApiGetAllApiV1TransactionGetRequest) CurrencyId(currencyId string) ApiGetAllApiV1TransactionGetRequest {
	r.currencyId = &currencyId
	return r
}

func (r ApiGetAllApiV1TransactionGetRequest) Symbol(symbol string) ApiGetAllApiV1TransactionGetRequest {
	r.symbol = &symbol
	return r
}

func (r ApiGetAllApiV1TransactionGetRequest) Network(network string) ApiGetAllApiV1TransactionGetRequest {
	r.network = &network
	return r
}

func (r ApiGetAllApiV1TransactionGetRequest) Status(status TransactionStatus) ApiGetAllApiV1TransactionGetRequest {
	r.status = &status
	return r
}

func (r ApiGetAllApiV1TransactionGetRequest) Late(late bool) ApiGetAllApiV1TransactionGetRequest {
	r.late = &late
	return r
}

func (r ApiGetAllApiV1TransactionGetRequest) Page(page int32) ApiGetAllApiV1TransactionGetRequest {
	r.page = &page
	return r
}

func (r ApiGetAllApiV1TransactionGetRequest) PageSize(pageSize int32) ApiGetAllApiV1TransactionGetRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetAllApiV1TransactionGetRequest) Start(start time.Time) ApiGetAllApiV1TransactionGetRequest {
	r.start = &start
	return r
}

func (r ApiGetAllApiV1TransactionGetRequest) End(end time.Time) ApiGetAllApiV1TransactionGetRequest {
	r.end = &end
	return r
}

func (r ApiGetAllApiV1TransactionGetRequest) Execute() (*PageTransactionResponse, *http.Response, error) {
	return r.ApiService.GetAllApiV1TransactionGetExecute(r)
}

/*
GetAllApiV1TransactionGet Get All

Get all transactions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllApiV1TransactionGetRequest
*/
func (a *TransactionAPIService) GetAllApiV1TransactionGet(ctx context.Context) ApiGetAllApiV1TransactionGetRequest {
	return ApiGetAllApiV1TransactionGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PageTransactionResponse
func (a *TransactionAPIService) GetAllApiV1TransactionGetExecute(r ApiGetAllApiV1TransactionGetRequest) (*PageTransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PageTransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionAPIService.GetAllApiV1TransactionGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payments/api/v1/transaction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.chargeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "charge_id", r.chargeId, "")
	}
	if r.currencyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency_id", r.currencyId, "")
	}
	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "")
	}
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network", r.network, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.late != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "late", r.late, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 0
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
	} else {
		var defaultValue int32 = 1
		r.pageSize = &defaultValue
	}
	if r.start != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "start", r.start, "")
	}
	if r.end != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "end", r.end, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HTTPResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOneApiV1TransactionTransactionIdGetRequest struct {
	ctx context.Context
	ApiService *TransactionAPIService
	transactionId string
}

func (r ApiGetOneApiV1TransactionTransactionIdGetRequest) Execute() (*TransactionResponse, *http.Response, error) {
	return r.ApiService.GetOneApiV1TransactionTransactionIdGetExecute(r)
}

/*
GetOneApiV1TransactionTransactionIdGet Get One

Get one pending transaction associated with a specific transaction_id or charge_id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param transactionId
 @return ApiGetOneApiV1TransactionTransactionIdGetRequest
*/
func (a *TransactionAPIService) GetOneApiV1TransactionTransactionIdGet(ctx context.Context, transactionId string) ApiGetOneApiV1TransactionTransactionIdGetRequest {
	return ApiGetOneApiV1TransactionTransactionIdGetRequest{
		ApiService: a,
		ctx: ctx,
		transactionId: transactionId,
	}
}

// Execute executes the request
//  @return TransactionResponse
func (a *TransactionAPIService) GetOneApiV1TransactionTransactionIdGetExecute(r ApiGetOneApiV1TransactionTransactionIdGetRequest) (*TransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionAPIService.GetOneApiV1TransactionTransactionIdGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payments/api/v1/transaction/{transaction_id}"
	localVarPath = strings.Replace(localVarPath, "{"+"transaction_id"+"}", url.PathEscape(parameterValueToString(r.transactionId, "transactionId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HTTPResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrUpdateApiV1TransactionPutRequest struct {
	ctx context.Context
	ApiService *TransactionAPIService
	transactionId *string
	chargeId *string
	symbol *string
	network *string
	currencyId *string
}

func (r ApiGetOrUpdateApiV1TransactionPutRequest) TransactionId(transactionId string) ApiGetOrUpdateApiV1TransactionPutRequest {
	r.transactionId = &transactionId
	return r
}

func (r ApiGetOrUpdateApiV1TransactionPutRequest) ChargeId(chargeId string) ApiGetOrUpdateApiV1TransactionPutRequest {
	r.chargeId = &chargeId
	return r
}

func (r ApiGetOrUpdateApiV1TransactionPutRequest) Symbol(symbol string) ApiGetOrUpdateApiV1TransactionPutRequest {
	r.symbol = &symbol
	return r
}

func (r ApiGetOrUpdateApiV1TransactionPutRequest) Network(network string) ApiGetOrUpdateApiV1TransactionPutRequest {
	r.network = &network
	return r
}

func (r ApiGetOrUpdateApiV1TransactionPutRequest) CurrencyId(currencyId string) ApiGetOrUpdateApiV1TransactionPutRequest {
	r.currencyId = &currencyId
	return r
}

func (r ApiGetOrUpdateApiV1TransactionPutRequest) Execute() (*TransactionResponse, *http.Response, error) {
	return r.ApiService.GetOrUpdateApiV1TransactionPutExecute(r)
}

/*
GetOrUpdateApiV1TransactionPut Get Or Update

Get one pending transaction associated with a specific transaction_id or charge_id.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOrUpdateApiV1TransactionPutRequest
*/
func (a *TransactionAPIService) GetOrUpdateApiV1TransactionPut(ctx context.Context) ApiGetOrUpdateApiV1TransactionPutRequest {
	return ApiGetOrUpdateApiV1TransactionPutRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return TransactionResponse
func (a *TransactionAPIService) GetOrUpdateApiV1TransactionPutExecute(r ApiGetOrUpdateApiV1TransactionPutRequest) (*TransactionResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TransactionResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TransactionAPIService.GetOrUpdateApiV1TransactionPut")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/payments/api/v1/transaction"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.transactionId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "transaction_id", r.transactionId, "")
	}
	if r.chargeId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "charge_id", r.chargeId, "")
	}
	if r.symbol != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "symbol", r.symbol, "")
	}
	if r.network != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "network", r.network, "")
	}
	if r.currencyId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency_id", r.currencyId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v HTTPResponse
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
