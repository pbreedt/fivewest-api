/*
FiveWest Client API

API Documentation for FiveWest's wallet and RfQ trading services. Please visit dashboard.fivewest.co.za to sign up. Once your account has been verified to the sufficient level necessary for the given service, you can create an API key and secret with fine-grained service permissions in the 'API Management' section of the 'Profile' tab. These credentials must be provided in the /profile/api/v1/auth/token route in order to acquire a JWT to make further requests with. This JWT is valid for one week; the credentials do not expire but may be deleted.

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package fivewestapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// APIAuthAPIService APIAuthAPI service
type APIAuthAPIService service

type ApiLoginApiV1AuthTokenPostRequest struct {
	ctx context.Context
	ApiService *APIAuthAPIService
	oAuth2ClientCredentialsRequestForm *OAuth2ClientCredentialsRequestForm
}

func (r ApiLoginApiV1AuthTokenPostRequest) OAuth2ClientCredentialsRequestForm(oAuth2ClientCredentialsRequestForm OAuth2ClientCredentialsRequestForm) ApiLoginApiV1AuthTokenPostRequest {
	r.oAuth2ClientCredentialsRequestForm = &oAuth2ClientCredentialsRequestForm
	return r
}

func (r ApiLoginApiV1AuthTokenPostRequest) Execute() (*Token, *http.Response, error) {
	return r.ApiService.LoginApiV1AuthTokenPostExecute(r)
}

/*
LoginApiV1AuthTokenPost Get OAuth2 access token from API key and secret

Gets a fresh JWT for a given API key and secret.

The token is only valid for 1 week - after with a new token must be fetched from this endpoint.

Body Parameters
-----------
- `key` **(required)**: API key.
- `secret` **(required)**: API secret.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiLoginApiV1AuthTokenPostRequest
*/
func (a *APIAuthAPIService) LoginApiV1AuthTokenPost(ctx context.Context) ApiLoginApiV1AuthTokenPostRequest {
	return ApiLoginApiV1AuthTokenPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return Token
func (a *APIAuthAPIService) LoginApiV1AuthTokenPostExecute(r ApiLoginApiV1AuthTokenPostRequest) (*Token, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Token
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "APIAuthAPIService.LoginApiV1AuthTokenPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/profile/api/v1/auth/token"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.oAuth2ClientCredentialsRequestForm == nil {
		return localVarReturnValue, nil, reportError("oAuth2ClientCredentialsRequestForm is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.oAuth2ClientCredentialsRequestForm
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
