/*
FiveWest Client API

API Documentation for FiveWest's wallet and RfQ trading services. Please visit dashboard.fivewest.co.za to sign up. Once your account has been verified to the sufficient level necessary for the given service, you can create an API key and secret with fine-grained service permissions in the 'API Management' section of the 'Profile' tab. These credentials must be provided in the /profile/api/v1/auth/token route in order to acquire a JWT to make further requests with. This JWT is valid for one week; the credentials do not expire but may be deleted.

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package fivewestapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// TradingPairInfoAPIService TradingPairInfoAPI service
type TradingPairInfoAPIService service

type ApiGetAllTradingPairsApiV1PairGetRequest struct {
	ctx context.Context
	ApiService *TradingPairInfoAPIService
	baseCurrency *string
	quoteCurrency *string
	isActive *bool
	page *int32
	pageSize *int32
}

func (r ApiGetAllTradingPairsApiV1PairGetRequest) BaseCurrency(baseCurrency string) ApiGetAllTradingPairsApiV1PairGetRequest {
	r.baseCurrency = &baseCurrency
	return r
}

func (r ApiGetAllTradingPairsApiV1PairGetRequest) QuoteCurrency(quoteCurrency string) ApiGetAllTradingPairsApiV1PairGetRequest {
	r.quoteCurrency = &quoteCurrency
	return r
}

func (r ApiGetAllTradingPairsApiV1PairGetRequest) IsActive(isActive bool) ApiGetAllTradingPairsApiV1PairGetRequest {
	r.isActive = &isActive
	return r
}

func (r ApiGetAllTradingPairsApiV1PairGetRequest) Page(page int32) ApiGetAllTradingPairsApiV1PairGetRequest {
	r.page = &page
	return r
}

func (r ApiGetAllTradingPairsApiV1PairGetRequest) PageSize(pageSize int32) ApiGetAllTradingPairsApiV1PairGetRequest {
	r.pageSize = &pageSize
	return r
}

func (r ApiGetAllTradingPairsApiV1PairGetRequest) Execute() ([]PairInfo, *http.Response, error) {
	return r.ApiService.GetAllTradingPairsApiV1PairGetExecute(r)
}

/*
GetAllTradingPairsApiV1PairGet Get All Trading Pairs

Get the quote lifetime and other details of all available currency pairs for trading.

Query Parameters
-----------
- `base_currency` **(optional)**: Filter by a particular base currency.
- `quote_currency` **(optional)**: Filter by a particular quote currency.
- `is_active` **(optional)**: Filter by whether a currency pair is active or not.
- `page` **(optional)**: Page pagination (defaults to 0).
- `page_size` **(optional)**: Page size pagination (defaults to 1).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllTradingPairsApiV1PairGetRequest
*/
func (a *TradingPairInfoAPIService) GetAllTradingPairsApiV1PairGet(ctx context.Context) ApiGetAllTradingPairsApiV1PairGetRequest {
	return ApiGetAllTradingPairsApiV1PairGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return []PairInfo
func (a *TradingPairInfoAPIService) GetAllTradingPairsApiV1PairGetExecute(r ApiGetAllTradingPairsApiV1PairGetRequest) ([]PairInfo, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []PairInfo
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "TradingPairInfoAPIService.GetAllTradingPairsApiV1PairGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/trading/api/v1/pair"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.baseCurrency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "base_currency", r.baseCurrency, "")
	}
	if r.quoteCurrency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "quote_currency", r.quoteCurrency, "")
	}
	if r.isActive != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "is_active", r.isActive, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	} else {
		var defaultValue int32 = 0
		r.page = &defaultValue
	}
	if r.pageSize != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page_size", r.pageSize, "")
	} else {
		var defaultValue int32 = 1
		r.pageSize = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 422 {
			var v HTTPValidationError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
